---
layout: post
title: "Day 5 - Merge Mechanic"
---

### What I Set Out to Do
Today was the most important part: making the mechanic for merging tiles. 
---

### What I Actually Did

I started with the left function. My first attempt was messy, since I was kind of lost. I decided to go through every row, iterate 4 times (kind of arbitrary), and delete 0s (adding them at the end later). If there is a non zero, check if there is a number behind it and add the index of the behind one to the merged number. 
~~~
def left(squares):
  for row in squares:
    for i in range(4):
      if row[i] == "0":
        del row[i]
      elif row[i] != "0":
        num = row[i]
        behind = row[0:i]
        if num in behind:
          index = behind.index(num)
          row[index] = str(int(row.pop(i))*2)
      while len(row) < 4:
        row.append("0")
~~~~
This code was not the best, and it introduced errors such as not working all the time, merging more times than the original game permits (tiles are only allowed to merge once per turn).
With this in mind, I tried this new design:
~~~
def left(squares):
  for r in range(4):
    # convert to int for easy processing and getting rid of 0s
    row = [int(x) for x in squares[r] if x != "0"]
    # using while loop since we change the length of the loop
    i = 0
    while i < len(row)-1:
      # check if the adjacent number is equal
      if row[i] == row[i + 1]:
        # Multiply the number by 2 and delete the adjacent number (it is ahead and this is the left function)
        row[i] *= 2
        del row[i + 1]
        # Iterating through while loop
        i += 1
      else:
        i += 1
    # Padding the right with zeros after moving left
    while len(row) < 4:
      row.append("0")
    # sending the updated row back to squares
    squares[r] = [str(x) for x in row]
~~~
This updated code got rid of the zeros so I only had to worry about the relations between neighboring numbers. I also converted everything to an int so the logic would be easier. 
I then used a similar logic, except backwards for the right function:
~~~
def right(squares):
  for r in range(4):
    # convert to int for easy processing and getting rid of 0s
    row = [int(x) for x in squares[r] if x != "0"]
    # using while loop since we change the length of the loop
    i = -1
    while i > -(len(row)):
      if row[i] == row[i - 1]:
        row[i] *= 2
        del row[i-1]
        i -= 1
      else:
        i -= 1
    while len(row) < 4:
      row.insert(0,"0")
    squares[r] = [str(x) for x in row]
~~~
Next, I needed to do the vertical functions
---

### What I Learned or Noticed

I noticed that games can often be more complex than they can seem. I realized that when I was playing 2048, I was thinking only on surface level and not how the game actually works. I did not even think to pay attention to when, where, and what numbers generate each turn. Next time I play a game, I will take note of all the subtle complexities that are not apparent to the naked eye.
---

### What's Next

The next stage is to start my actual program for 2048.

