---
layout: post
title: "Day 5 - Merge Mechanic"
---

### What I Set Out to Do
Today was the most important part: making the mechanic for merging tiles. 
---

### What I Actually Did

I started with the left function. My first attempt was messy, since I was kind of lost. I decided to go through every row, iterate 4 times (kind of arbitrary), and delete 0s (adding them at the end later). If there is a non zero, check if there is a number behind it and add the index of the behind one to the merged number. 
~~~
def left(squares):
  for row in squares:
    for i in range(4):
      if row[i] == "0":
        del row[i]
      elif row[i] != "0":
        num = row[i]
        behind = row[0:i]
        if num in behind:
          index = behind.index(num)
          row[index] = str(int(row.pop(i))*2)
      while len(row) < 4:
        row.append("0")
~~~~
This code was not the best, and it introduced errors such as not working all the time, merging more times than the original game permits (tiles are only allowed to merge once per turn).
With this in mind, I tried this new design:
~~~
def left(squares):
  for r in range(4):
    # convert to int for easy processing and getting rid of 0s
    row = [int(x) for x in squares[r] if x != "0"]
    # using while loop since we change the length of the loop
    i = 0
    while i < len(row)-1:
      # check if the adjacent number is equal
      if row[i] == row[i + 1]:
        # Multiply the number by 2 and delete the adjacent number (it is ahead and this is the left function)
        row[i] *= 2
        del row[i + 1]
        # Iterating through while loop
        i += 1
      else:
        i += 1
    # Padding the right with zeros after moving left
    while len(row) < 4:
      row.append("0")
    # sending the updated row back to squares
    squares[r] = [str(x) for x in row]
~~~
This updated code got rid of the zeros so I only had to worry about the relations between neighboring numbers. I also converted everything to an int so the logic would be easier. 
~~~

~~~
This helped me understand what all the parts of the code did and I practiced using random and pygame together.

#### **2048 research**

For my research, I started with playing many games of 2048, which was fun. There were some statistics I was still curious about, so I consulted the 2048 wikipedia page for information on how some of the game mechanics work. The game starts with 2 numbers in random places. New numbers generate in completely random empty squares every time a move is made, which disproved my previous notion that they generate based on which direction you move. Also, there is a 90% chance for a new number to be 2 and a 10% chance for it to be a 4.
---

### What I Learned or Noticed

I noticed that games can often be more complex than they can seem. I realized that when I was playing 2048, I was thinking only on surface level and not how the game actually works. I did not even think to pay attention to when, where, and what numbers generate each turn. Next time I play a game, I will take note of all the subtle complexities that are not apparent to the naked eye.
---

### What's Next

The next stage is to start my actual program for 2048.

