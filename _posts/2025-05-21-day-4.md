---
layout: post
title: "Day 4 - Merge Mechanic"
---

### What I Set Out to Do
Today was the most important part: making the mechanic for merging tiles. 
---

### What I Actually Did

I started with the left function. My first attempt was messy, since I was kind of lost. I decided to go through every row, iterate 4 times (kind of arbitrary), and delete 0s (adding them at the end later). If there is a 
~~~
def left(squares):
  for row in squares:
    for i in range(4):
      if row[i] == "0":
        del row[i]
      elif row[i] != "0":
        num = row[i]
        behind = row[0:i]
        if num in behind:
          index = behind.index(num)
          row[index] = str(int(row.pop(i))*2)
      while len(row) < 4:
        row.append("0")
~~~~
Then, I set up a basic code to generate 2 random numbers in random positions before the infinite pygame loop starts.
~~~
# iterating twice
for i in range(2):
    # generating random number with 10% chance of a 4
    random_square = 2 + 2 * (random.randint(1,10) == 10)

    # random index from 0 to end of list
    random_index = random.randint(0,15)
    
    squares[random_index] = random_square
~~~
Then, in the loop, I added the random generation feature using pygame events:
~~~
while running:
    events = pygame.event.get()
    for event in events:
        if event.type == pygame.QUIT:
            running = False

        # Filling a random number every time a key is pressed
        if event.type == pygame.KEYDOWN and event.key in (pygame.K_LEFT, pygame.K_RIGHT, pygame.K_UP, pygame.K_DOWN):
            # uses the enumerate feature to count indices and evaluate if it is 0
            empty_indices = [i for i, v in enumerate(squares) if v == 0]
            
            if empty_indices:
                # using random choice in the empty indices
                new_index = random.choice(empty_indices)

                
                squares[new_index] = 2 * (random.randint(1, 10) == 10)
                print(squares)

    screen.fill(color)
    
    for i in range(0,4):
        pygame.draw.line(screen,(0,0,0), (125*i,0), (125*i,500))
        pygame.draw.line(screen,(0,0,0), (0,125*i), (500,125*i))
        for j in range(0,4):
            draw_text(str(squares[(i*4)+j]),text_font, (0,0,0),125*j + 50, 125*i+50)
    """
    draw_text(str(squares), text_font, (0,0,0),0, 125)
    """
    pygame.display.flip()
~~~
This helped me understand what all the parts of the code did and I practiced using random and pygame together.

#### **2048 research**

For my research, I started with playing many games of 2048, which was fun. There were some statistics I was still curious about, so I consulted the 2048 wikipedia page for information on how some of the game mechanics work. The game starts with 2 numbers in random places. New numbers generate in completely random empty squares every time a move is made, which disproved my previous notion that they generate based on which direction you move. Also, there is a 90% chance for a new number to be 2 and a 10% chance for it to be a 4.
---

### What I Learned or Noticed

I noticed that games can often be more complex than they can seem. I realized that when I was playing 2048, I was thinking only on surface level and not how the game actually works. I did not even think to pay attention to when, where, and what numbers generate each turn. Next time I play a game, I will take note of all the subtle complexities that are not apparent to the naked eye.
---

### What's Next

The next stage is to start my actual program for 2048.

